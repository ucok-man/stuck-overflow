// datasource and generator remain the same
datasource db {
    provider  = "postgresql"
    url       = env("DATABASE_URL")
    directUrl = env("DATABASE_URL_UNPOOLED")
}

generator client {
    // provider        = "prisma-dbml-generator"
    provider        = "prisma-client-js"
    previewFeatures = ["fullTextSearchPostgres"]
}

model User {
    id               String   @id @default(cuid())
    clerkId          String   @unique
    name             String
    username         String   @unique
    email            String   @unique
    password         String?
    bio              String?
    picture          String
    location         String?
    portfolioWebsite String?
    reputation       Int      @default(0)
    joinedAt         DateTime @default(now())

    questions          Question[] @relation("questionCreated")
    savedQuestions     Question[] @relation("questionSaved")
    upvotedQuestions   Question[] @relation("questionUpvoted")
    downvotedQuestions Question[] @relation("questionDownvoted")
    answers            Answer[]   @relation("answerCreated")
    upvotedAnswers     Answer[]   @relation("answerUpvoted")
    downvotedAnswers   Answer[]   @relation("answerDownvoted")
    followedTags       Tag[]      @relation("tagFollowed")

    interactions Interaction[]
}

model Question {
    id        String   @id @default(cuid())
    title     String
    content   String
    views     Int      @default(0)
    createdAt DateTime @default(now())

    authorId String
    author   User   @relation("questionCreated", fields: [authorId], references: [id], onDelete: Cascade)

    answers   Answer[] @relation("questionAnswers")
    tags      Tag[]    @relation("questionTag")
    upvotes   User[]   @relation("questionUpvoted")
    downvotes User[]   @relation("questionDownvoted")
    savedBy   User[]   @relation("questionSaved")

    interactions Interaction[]
}

model Answer {
    id        String   @id @default(cuid())
    content   String
    createdAt DateTime @default(now())

    authorId String
    author   User   @relation("answerCreated", fields: [authorId], references: [id], onDelete: Cascade)

    questionId String
    question   Question @relation("questionAnswers", fields: [questionId], references: [id], onDelete: Cascade)

    upvotes   User[] @relation("answerUpvoted")
    downvotes User[] @relation("answerDownvoted")
}

model Tag {
    id        String   @id @default(cuid())
    name      String   @unique
    createdOn DateTime @default(now())

    questions Question[] @relation("questionTag")
    followers User[]     @relation("tagFollowed")

    interactions Interaction[]
}

model Interaction {
    id        String              @id @default(cuid())
    actions   InteractionAction[]
    createdAt DateTime            @default(now())

    tags Tag[]

    userId String
    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

    questionId String?
    question   Question? @relation(fields: [questionId], references: [id], onDelete: Cascade)

    @@unique([userId, questionId])
}

enum InteractionAction {
    ASK_QUESTION
    ANSWER
    SAVE_QUESTION
}
